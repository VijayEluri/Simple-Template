// PROJECT_NAME is defined in settings.gradle
group 'com.jaliansystems'
version '1.1-SNAPSHOT'

apply plugin: 'java'
apply plugin: 'maven-publish'
apply plugin: 'signing'
apply plugin: 'eclipse'
apply plugin: 'distribution'

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'me.trnl:github-release-gradle-plugin:0.1'
    }
}

apply plugin: 'git'
apply plugin: 'console'
apply plugin: 'github'
apply plugin: 'release'

ext {
    pomFile = file("${project.buildDir}/generated-pom.xml")
    isReleaseVersion = !(project.version =~ /-SNAPSHOT$/)
}

repositories {
	mavenLocal()
    mavenCentral()
}

dependencies {
    testCompile 'junit:junit:4.12'
}

task sourceJar(type: Jar, dependsOn: classes) {
	classifier 'sources'
	from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
	classifier = 'javadoc'
	from javadoc.destinationDir
}

artifacts {
    archives jar
    archives sourceJar
    archives javadocJar
}

signing {
    required { signatory != null && project.ext.isReleaseVersion }
    sign configurations.archives
}

publishing {
    repositories {
        maven {
            if (project.ext.isReleaseVersion) {
                url 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
            } else {
                url 'https://oss.sonatype.org/content/repositories/snapshots/'
            }

            credentials {
                username = mvnUser
                password = mvnPassword
            }
        }
    }

	publications {
		jar(MavenPublication) {
			pom.withXml {
				asNode().with {
					appendNode('packaging', 'jar')
					appendNode('name', 'simple-template')
					appendNode('description', 'simple-template does one thing - that is converting a model into another language - and does it well.')
					appendNode('url', 'https://github.com/jalian-systems/Simple-Template')
					appendNode('scm').with {
						appendNode('url', 'https://github.com/jalian-systems/Simple-Template')
						appendNode('connection', 'https://github.com/jalian-systems/Simple-Template')
					}
					appendNode('issueManagement').with {
						appendNode('url', 'https://github.com/jalian-systems/Simple-Template/issues')
						appendNode('system', 'GitHub')
					}
					appendNode('licenses').with {
						appendNode('license').with {
							appendNode('name', 'Apache License')
							appendNode('url', 'http://www.apache.org/licenses/')
						}
					}
					appendNode('organization').with {
						appendNode('name', 'Jalian Systems Pvt. Ltd.')
						appendNode('url', 'http://jaliansystems.com')
					}
					appendNode('developers').with {
						appendNode('developer').with {
							appendNode('id', 'dakshinamurthy.karra')
							appendNode('name', 'Dakshinamurthy Karra')
							appendNode('email', 'dakshinamurthy.karra@jaliansystems.com')
							appendNode('organization', 'Jalian Systems Pvt. Ltd.')
							appendNode('organizationUrl', 'http://jaliansystems.com')
							appendNode('timezone', 'IST (UTC +5:30)')
						}
					}
				}
			}

			from components.java

			tasks.withType(Jar) {
				from(project.projectDir) {
					include 'LICENSE.txt'
					into 'META-INF'
				}
			}

            artifact(sourceJar) {
                classifier = 'sources'
            }

            artifact(javadocJar) {
                classifier = 'javadoc'
            }

            // Sign the pom.xml and artifacts.
            if (signing.required) {
                // Sign the pom.xml.
                pom.withXml {
                    writeTo(project.ext.pomFile)
                    def pomAscFile = signing.sign(project.ext.pomFile).signatureFiles[0]
                    artifact(pomAscFile) {
                        classifier = null
                        extension = 'pom.asc'
                    }
                    project.ext.pomFile.delete()
                }

                // Sign the artifacts.
                project.tasks.signArchives.signatureFiles.each {
                    artifact(it) {
                        def matcher = it.file =~ /-(sources|javadoc)\.jar\.asc$/
                        if (matcher.find()) {
                            classifier = matcher.group(1)
                        } else {
                            classifier = null
                        }
                        extension = 'jar.asc'
                    }
                }
            }
		}
	}
}

github {
    /* Wiki repo will be calculated from this. */
    repo = 'git@github.com:jalian-systems/Simple-Template.git'

    release {
        /* Use {} brackets for lazy evaluation */
        tag = { "r$project.release.version" }
        name = { "$project.release.version" }
    }
}

release {
    /* Let's check that everything is committed */
    doFirst {
        if (!project.git.status().isEmpty()) {
            throw new GradleException('You have uncommitted changes.')
        }
    }

    /* Ask user for a release version, suggesting some default variant. */
    version = { console.prompt(' > Please enter release version:', project.version - '-SNAPSHOT') }
    tag = { "r$project.release.version" }
    commitMessage = { "Release $project.release.version" }

    /* Files and projects that needs to be updated with a new release version. */
    update {
        file project.file('build.gradle')
    }

    /* Spec for next version. As above, asking user input. */
    next {
        version = { console.prompt(' > Please enter next version:', bumpVersion(project.release.version)) }
        commitMessage = { "Bumping version to $project.release.next.version" }
    }

    /* Tasks that needs to be performed during release. Will be done after tag step. */
    dependsOn draftGhRelease
}

model {
    tasks.publishJarPublicationToMavenLocal {
        dependsOn(project.tasks.signArchives)
    }
    tasks.publishJarPublicationToMavenRepository {
        dependsOn(project.tasks.signArchives)
    }
}

task updateDocs(type: Copy) {
	from 'build/docs/javadoc'
	into 'docs/javadoc'
}

build.dependsOn(updateDocs)
